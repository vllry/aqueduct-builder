#!/usr/bin/python3

from threading import Thread
import json
from queue import Full
from sys import exit
from os import getuid, mkdir, remove
from bottle import route, run, request, static_file, abort

import libaqueduct as lib
import libaqueductbuilder as builder



conf = builder.conf



@route('/', method='GET')
def get_info():
	cur = builder.CurrentBuild()
	info = {
		'service': 'aqueduct-builder',
		'name': conf['name'],
		'version': '{{VERSION}}',
		'arch': builder.get_arch(),
		'os': builder.get_os(),
		'queue': buildqueue.list(),
		'building': cur.dictionary
		}
	return json.dumps(info)



@route('/build/submit', method='POST')
def build_submit():
	upload = request.files.data
	callbackurl = request.forms.get('callbackurl')
	jobid = request.forms.get('jobid')
	arch = request.forms.get('arch')
	os = request.forms.get('os')
	release = request.forms.get('release')

	if not upload or not upload.file:
		return {'success': False, 'message': 'No file supplied'}
	elif not callbackurl:
		return {'success': False, 'message': 'No callbackurl supplied'}
	elif not jobid:
		return {'success': False, 'message': 'No jobid supplied'}
	elif not arch:
		return {'success': False, 'message': 'No arch supplied'}
	elif not os:
		return {'success': False, 'message': 'No os supplied'}
	elif not release:
		return {'success': False, 'message': 'No release supplied'}

	upload.save(conf['dir']['intake'])
	buildid = builder.new_buildid()
	path_to_source = conf['dir']['intake'] + upload.filename

	try:
		buildqueue.enqueue_nowait({'buildid': buildid, 'jobid': jobid, 'arch': arch, 'os': os, 'release': release, 'source': path_to_source, 'callbackurl': callbackurl})
	except Full:
		remove(path_to_source)
		return {
			'success': False,
			'message': 'Job queue is full'
			}
	else:
		mkdir(conf['dir']['result'] + buildid) #Make the build dir, since we've now associated the id with the task, and the dirs are used to determine ids

	return {
			'success': True,
			'message': 'Job successfully submitted',
			'id': buildid
			}



@route('/build/<buildid>/log')
def get_build_log(buildid):
	return static_file('build.log', conf['dir']['result'] % buildid)



@route('/build/<buildid>/deb')
def get_build_deb(buildid):
	filename = builder.get_build_file_that_ends_in(buildid, '.deb')
	if filename:
		return static_file(filename[0], filename[1])
	else:
		abort(404, 'No file exists, perhaps the build failed?')



@route('/build/<buildid>/tarball')
def get_build_tarball(buildid):
	filename = builder.get_build_file_that_ends_in(buildid, '.tar.xz')
	if filename:
		return static_file(filename[0], filename[1])
	else:
		abort(404, 'No file exists, perhaps the build failed?')



@route('/build/<buildid>/dsc')
def get_build_dsc(buildid):
	filename = builder.get_build_file_that_ends_in(buildid, '.dsc')
	if filename:
		return static_file(filename[0], filename[1])
	else:
		abort(404, 'No file exists, perhaps the build failed?')



@route('/build/<buildid>/changes')
def get_build_changes(buildid):
	filename = builder.get_build_file_that_ends_in(buildid, '.changes')
	if filename:
		return static_file(filename[0], filename[1])
	else:
		abort(404, 'No file exists, perhaps the build failed?')



if getuid() != 0:
	print('Please run aqueduct-builder as root')
	exit(1)

buildqueue = lib.PriorityQueue()
builder_thread = Thread(target=builder.daemon, args=(buildqueue,))
builder_thread.start()
run(host='', port=conf['port'], debug=True)
